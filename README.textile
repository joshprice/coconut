Coconut is a <b>jQuery plugin</b>, it is designed to simplify and guide the <b>Object-Oriented</b> encapsulation of client side Javascript code. It's specially useful when creating complicated <b>Form</b> based app with rich client side logic.

h1. Get Started

h2. Two Minutes' Tour

h3. Build a Part

Given partial page as below:

<pre>
<div id="person">
    <input type="text" name="name" value="luning"/>
    <select name="title">
        <option>Mr</option>
        <option>Mrs</option>
    </select>
</div>
</pre>

Then:

<pre>
var person = $("#person").part();
</pre>

Will build a <b>PART</b> representing person with all <b>FIELD</b>s setted up automatically, you can do:

h3. State and Field Operations

<pre>
var theName = person.name.state();
</pre>

theName is "luning". "name" is one field of person, state() will return value of the field, similar as val() on jQuery object.

<pre>
person.name.state("smith");
</pre>

Set state of "name" field to new value, similar as val("smith") on jQuery but with proper events fired as what happens in real user interactions.

<pre>
var theState = person.state();
</pre>

theState is an object { name: "smith", title: "Mr" }, this is the current state of the part.

<pre>
person.state( {name: "jessie", title: "Mrs"} );
</pre>

Set new state of person part, with events(e.g. change, blur) fired, which will trigger proper handlers.

<pre>
var dirty = person.isDirty();
</pre>

dirty is true, since the state of person is changed after initialization.

<pre>
person.resetState();
</pre>

Set state back to the initial one { name: "luning", title: "Mr" }.

h3. Binding and Event Operations

<pre>
person.name.bindState("#id_of_a_label");
</pre>

Any change of name will update the value of target label specified by jQuery selector.

<pre>
person.bindState("#id_of_summary_span", function(s){
    return "summary: " + s.title + " " + s.name + " (" + s.gender + ")";
});
</pre>

Any field change in person will update the summary span by applying a converter function.

<pre>
person.name.change(function(){ /* custom logic */});
person.change(function(){ /* custom logic */});
</pre>

Change of field or person part will trigger custom handlers.

h2. Learn More

h3. Mixin Behaviors

You can extend part by mixing in behavior(s).

<pre>
function Person(){
    this.summary = function(){
        var s = this.state();
        return s.title + " " + s.name + " (" + s.gender + ")";
    }
}

var person = $("#person").part(Person);
var summary = person.summary();
</pre>

Define behavior Person as a function, build part with the behavior, and summary() method is mixed into the part.

Behavior is actually the place you should arrange custom client side logic about person part.

You can also specify the behavior(function) in Dom element by setting the custom "part" property:

<pre>
<div id="person" part="Person">
  ...
</div>
</pre>

Then:

<pre>
var person = $("#person").part();
var summary = person.summary();
</pre>

Coconut will pick the behavior up and apply it for you automatically.

h3. Build a Composite Part

You are allowed to build a composite part with another part as field by setting up "part" property on any Dom element which can be used as a container.

With this dom:

<pre>
<div id="person">
  ...
  <div part="" name="contact">
 	  <input type="text" name="number"/>
	  <input type="text" name="type"/>
  </div>
</div>
</pre>

Then:

<pre>
var person = $("#person").part();

var personState = person.state();
var contactState = person.contact.state();
var numberState = person.contact.number.state();
</pre>

personState is { name: "luning", title: "Mr", contact: {number: "", type: ""} }.

contactState is {number: "", type: ""}.

numberState is "".

Build a part with a field containing an array of sub-fields with the same name (e.g. person may have multiple emails) by setting "fieldtype" property to "array" on Dom element.

With this dom:

<pre>
<div id="person">
  ...
  <input type="text" fieldtype="array" value="a@my.com" name="email"/>
  <input type="text" value="b@my.com" name="email"/>
</div>
</pre>

Then:

<pre>
var person = $("#person").part();

var personState = person.state();
var emailsState = person.emails.state();
var firstEmailState = person.emails[0].state();
</pre>

personState is { name: "", title: "Mr", emails: ["a@my.com", "b@my.com"] }.

emailsState is ["a@my.com", "b@my.com"].

firstEmailState is "a@my.com"

h3. Dynamic Behavior (Sync Between Dom and Part)

Adding Dom element(s) dynamically will add corresponding field(s) as well, any event registered on part works for the newly added field(s).

Given two emails in dom already, then:

<pre>
var person = $("#person").part();

var newEmail = $("<input type="text" name="email"></input>");
person.container.append(newEmail);
newEmail.sync();

var emailCount = person.emails.length;
</pre>

emailCount is 3, reflects the added email. 

Coconut extends jQuery with sync() method, call it after Dom is added.

The same thing happens when removing Dom element(s) from Dom, field(s) will be removed.

Given two emails in dom already, then:

<pre>
var person = $("#person").part();

person.container.find("input[name=email]:last").remove();
person.sync();

var emailCount = person.emails.length;
</pre>

emailCount is 1, reflects the removal.

Call sync() on part after removing dom.

h1. Rationale

h1. Design Suggestions

h1. API Reference

h1. Q&A
