Coconut is a *jQuery plugin* designed to simplify working with complex forms. It provides an *Object-Oriented* encapsulation of forms and their field groups using a straighforward declarative syntax. It enables some very powerful ways for decomposing forms into conceptual parts, and provides meaningful abstractions for these parts.

h1. Get Started

h2. Two Minute Tour

h3. Build a Part

Given an HTML snippet:

<pre>
  <div id="person">
    <select name="title">
        <option>Mr</option>
        <option checked="checked">Mrs</option>
    </select>
    <input type="text" name="firstname" value="Jane"/>
    <input type="text" name="lastname" value="Doe"/>
  </div>
</pre>

You create a *part* like this:

<pre>
  var person = $("#person").part();
</pre>

This builds a *part* representing @person@ with all *fields* set up automatically from their *name* attribute of the input field.

(The fields are actually jQuery wrappers of each form field element in the specified *part*)

<pre>
  person.title;
  person.firstname;
  person.lastname;
</pre>


h3. State and Field Operations

@firstname@ is a person field and calling @state()@ will simply return the field value, just like @val()@ on a jQuery object.

<pre>
  person.firstname.state();
  #=> "Jane"
</pre>

To change @firstname@ to new value, just pass the value into the @state()@ method. 

<pre>
  person.firstname.state("John");
</pre>

This is just like @person.firstname.val("John")@ in jQuery, but with the appropriate events are fired as if a real user typed the value into the field.

Setting the values of the entire person part is just as easy!

<pre>
  person.state({ title: "Mr", firstname: "John", lastname: "Smith"});
</pre>

Remember that all the user events get fired (ie. change, blur, click, etc).

Calling @state()@ on the person part simply returns the current state of the part as an object:

<pre>
  person.state();
  #=> { title: "Mr", firstname: "John", lastname: "Smith"}
</pre>

You can tell if the state has changed with @isDirty()@:

<pre>
  person.isDirty();
  #=> true
</pre>

Person is flagged as dirty, since the state of person has been changed since initialization.

Set the original state to the part with @resetState()@

<pre>
  person.resetState();
  #=> { title: "Mrs", firstname: "Jane", lastname: "Doe"}
</pre>


h3. Binding and Event Operations

<pre>
  person.name.bindState("#id_of_a_label");
</pre>

Any change of name will update the value of target label specified by jQuery selector.

<pre>
  person.bindState("#id_of_summary_span", function(s){
      return "summary: " + s.title + " " + s.name + " (" + s.gender + ")";
  });
</pre>

Any field change in person will update the summary span by applying a converter function.

<pre>
  person.name.change(function(){ /* custom logic */});
  person.change(function(){ /* custom logic */});
</pre>

Change of field or person part will trigger custom handlers.

h2. Learn More

h3. Mixin Behaviors

You can extend part by mixing in behavior(s).

<pre>
  function Person(){
      this.summary = function(){
          var s = this.state();
          return s.title + " " + s.name + " (" + s.gender + ")";
      }
  }

  var person = $("#person").part(Person);
  var summary = person.summary();
</pre>

Define behavior @Person@ as a function, build part with the behavior, and @summary()@ method is mixed into the part.

_**Behavior is actually the place you should arrange custom client side logic about person part.**_

You can also specify the behavior(function) in Dom element by setting the custom @part@ property:

<pre>
  <div id="person" part="Person">
    ...
  </div>
</pre>

Then:

<pre>
  var person = $("#person").part();
  var summary = person.summary();
</pre>

Coconut will pick the behavior up and apply it for you automatically.

h3. Build a Composite Part

You are allowed to build a composite part with another part as field by setting up @part@ property on any Dom element which can be used as a container.

With this Dom:

<pre>
  <div id="person">
    ...
    <div part="" name="contact">
      <input type="text" name="number"/>
      <input type="text" name="type"/>
    </div>
  </div>
</pre>

Then:

<pre>
  var person = $("#person").part();
  
  var personState = person.state();
  var contactState = person.contact.state();
  var numberState = person.contact.number.state();
</pre>

@personState@ is @{ name: "luning", title: "Mr", contact: {number: "", type: ""} }@.

@contactState@ is @{number: "", type: ""}@.

@numberState@ is @""@.

Build a part with a field containing an array of sub-fields with the same name (e.g. person may have multiple emails) by setting @fieldtype@ property to @array@ on Dom element.

With this Dom:

<pre>
  <div id="person">
    ...
    <input type="text" fieldtype="array" value="a@my.com" name="email"/>
    <input type="text" value="b@my.com" name="email"/>
  </div>
</pre>

Then:

<pre>
  var person = $("#person").part();

  var personState = person.state();
  var emailsState = person.emails.state();
  var firstEmailState = person.emails[0].state();
</pre>

@personState@ is @{ name: "", title: "Mr", emails: ["a@my.com", "b@my.com"] }@.

@emailsState@ is @["a@my.com", "b@my.com"]@.

@firstEmailState@ is @"a@my.com"@.

h3. Dynamic Behavior (Sync Between Dom and Part)

Adding Dom element(s) dynamically will add corresponding field(s) as well, any event registered on part works for the newly added field(s).

Given two emails in Dom already, then:

<pre>
  var person = $("#person").part();

  var newEmail = $("<input type="text" name="email"></input>");
  person.container.append(newEmail);
  newEmail.sync();

  var emailCount = person.emails.length;
</pre>

@emailCount@ is @3@, reflects the added email. 

Coconut extends jQuery with @sync()@ method, call it after Dom is added.

The same thing happens when removing Dom element(s) from Dom, field(s) will be removed.

Given two emails in Dom already, then:

<pre>
  var person = $("#person").part();

  person.container.find("input[name=email]:last").remove();
  person.sync();

  var emailCount = person.emails.length;
</pre>

@emailCount@ is @1@, reflects the removal.

Call @sync()@ on part after removing Dom.

h1. Rationale

h1. Design Suggestions

h1. API Reference

h1. Q&A
